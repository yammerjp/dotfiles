#!/usr/bin/env node

/*
 * TODO: implements command line options
 *  --help -h
 *  --silent -s
 */

const helpMessage = `Usage:    j-j <a JavaScript code piece to process JSON following "output = input ">

j-j is a JSON processor that can be written in a JavaScript code piece.
The command line argument code piece is interpreted as follows.

    eval("output = input " + <A CODE PIECE WITH COMMAND LINE ARGUMENT>)

The following variables are available in the code piece.

- input ... JavaScript object input as JSON from STDIN
- output ... JavaScript object output as JSON to STDOUT
- stdin ... String input from STDIN
- stdout ... String output to STDOUT (Preferred over output, if not null or undefined)

Examples of execution is shown below.

    $ echo '{"name":"bob","like":["sushi","orange"]}' | j-j '.like'
    [
     "sushi",
     "orange"
    ]

    $ echo '{"name":"bob","like":["sushi","orange"]}' | j-j '&& Object.keys(input)'
    [
     "name",
     "like"
    ]

    $ echo '{"name":"bob","like":["sushi","orange"]}' | j-j '; stdout = input.like.join("&")'
    sushi&orange
`;

function processJSON(input, stdin, code) {
  let output, stdout;
  eval("output = input" + code);
  return { stdout, output }
}

async function getStringFromStdin() {
  const buffers = [];
  for await (const chunk of process.stdin) buffers.push(chunk);
  return Buffer.concat(buffers).toString();
}

async function getInput() {
  const stdin = await getStringFromStdin();
  let input;
  try {
    input = JSON.parse(stdin);
  } catch {
    console.error('failed to parse json from STDIN');
    input = undefined;
  }
  return { stdin, input }
}

async function main() {
  if (process.stdin.isTTY) {
    console.error(helpMessage);
    process.exit();
  }

  const { stdin, input } = await getInput();

  const code = process.argv.slice(2).join(' ');

  const { stdout, output } = processJSON(input, stdin, code);

  console.log(stdout ?? JSON.stringify(output, null, ' '));
}

main();
